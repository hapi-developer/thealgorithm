<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Salient Pattern Miner (Contrastive PCA) — JS Linear Algebra</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; }
    h1 { margin: 0 0 8px; font-size: 18px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; }
    .col { flex: 1 1 420px; min-width: 320px; }
    textarea { width: 100%; height: 220px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size: 12px; }
    label { display: inline-block; margin: 6px 0; }
    input[type="text"], input[type="number"] { width: 160px; padding: 4px; }
    .controls { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; margin: 10px 0; }
    button { padding: 8px 12px; cursor: pointer; }
    pre { background: #f6f7f8; padding: 12px; overflow: auto; border-radius: 10px; }
    table { border-collapse: collapse; width: 100%; font-size: 13px; }
    th, td { border: 1px solid #ddd; padding: 6px 8px; vertical-align: top; }
    th { background: #fafafa; text-align: left; }
    .small { font-size: 12px; color: #444; }
    canvas { width: 100%; max-width: 720px; height: 420px; border: 1px solid #ddd; border-radius: 10px; }
    .warn { background:#fff3cd; border:1px solid #ffeeba; padding:10px; border-radius:10px; margin:10px 0; }
  </style>
</head>
<body>
  <h1>Salient Pattern Miner (Contrastive PCA) — 100% JavaScript Linear Algebra</h1>
  <div class="small">
    Paste two CSVs with the <b>same columns</b>: Target (experiment) and Background (control).
    Output highlights features enriched in Target vs Background, plus outliers.
  </div>

  <div class="warn small">
    This is a discovery/exploration tool (hypothesis generator). Don’t use it as medical advice or a diagnostic.
  </div>

  <div class="row">
    <div class="col">
      <h3 style="margin:10px 0 6px;">Target CSV (experiment / condition)</h3>
      <textarea id="csvTarget" placeholder="Example:
geneA,geneB,geneC
1.2,0.1,3.4
0.9,0.2,3.1
..."></textarea>
    </div>
    <div class="col">
      <h3 style="margin:10px 0 6px;">Background CSV (control / baseline)</h3>
      <textarea id="csvBg" placeholder="Optional (if empty, runs normal PCA on Target)"></textarea>
    </div>
  </div>

  <div class="controls">
    <label>Delimiter:
      <input id="delim" type="text" value="," />
    </label>
    <label>
      <input id="hasHeader" type="checkbox" checked />
      Has header row
    </label>
    <label>Components (k):
      <input id="k" type="number" value="3" min="1" max="20" />
    </label>
    <label>Power iters:
      <input id="iters" type="number" value="250" min="30" max="3000" />
    </label>
    <label>Alpha candidates:
      <input id="alphas" type="text" value="0,0.1,0.2,0.5,1,2,5,10" />
    </label>
    <label>
      <input id="standardizeOnBg" type="checkbox" checked />
      Standardize using Background stats (recommended if Background provided)
    </label>
    <button id="runBtn">Run cPCA</button>
    <button id="demoBtn">Load tiny demo</button>
    <button id="downloadBtn" disabled>Download results.json</button>
  </div>

  <h3 style="margin:10px 0 6px;">Scatter (Component 1 vs 2)</h3>
  <canvas id="plot" width="900" height="520"></canvas>

  <h3 style="margin:10px 0 6px;">Results</h3>
  <div id="results"></div>

  <script>
    /***********************************************************************
     * Salient Pattern Miner — Contrastive PCA (cPCA)
     * - Pure JS linear algebra (no libs)
     * - Covariances: Ct, Cb
     * - For alpha in candidates, compute M = Ct - alpha * Cb
     * - Find top-k eigenvectors of symmetric M (power iteration + deflation)
     * - Pick alpha that maximizes sum of positive eigenvalues (salient score)
     * - Report top feature loadings per component and outliers (T² + Q/SPE)
     ***********************************************************************/

    // ---------- Utilities ----------
    const EPS = 1e-12;

    function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }
    function isFiniteNumber(x) { return Number.isFinite(x) && !Number.isNaN(x); }

    function mulberry32(seed) {
      let t = seed >>> 0;
      return function() {
        t += 0x6D2B79F5;
        let r = Math.imul(t ^ (t >>> 15), 1 | t);
        r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
        return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
      };
    }

    function mean(arr) {
      let s = 0;
      for (let i = 0; i < arr.length; i++) s += arr[i];
      return s / Math.max(1, arr.length);
    }

    function std(arr) {
      const m = mean(arr);
      let v = 0;
      for (let i = 0; i < arr.length; i++) {
        const d = arr[i] - m;
        v += d * d;
      }
      v /= Math.max(1, arr.length - 1);
      return Math.sqrt(v + EPS);
    }

    // ---------- CSV Parsing ----------
    function parseCSV(text, delim, hasHeader) {
      const lines = text
        .split(/\r?\n/)
        .map(s => s.trim())
        .filter(s => s.length > 0);

      if (lines.length === 0) return { header: null, rows: [] };

      let header = null;
      let start = 0;
      if (hasHeader) {
        header = lines[0].split(delim).map(s => s.trim());
        start = 1;
      }

      const rows = [];
      let width = null;

      for (let i = start; i < lines.length; i++) {
        const parts = lines[i].split(delim).map(s => s.trim());
        if (width == null) width = parts.length;
        if (parts.length !== width) continue; // skip ragged lines

        const row = new Array(width);
        for (let j = 0; j < width; j++) {
          const v = parts[j];
          if (v === "" || v.toLowerCase() === "na" || v.toLowerCase() === "nan") {
            row[j] = NaN;
          } else {
            const num = Number(v);
            row[j] = Number.isFinite(num) ? num : NaN;
          }
        }
        rows.push(row);
      }

      // If no header, synthesize names
      if (!header && rows.length > 0) {
        header = Array.from({ length: rows[0].length }, (_, i) => `x${i+1}`);
      }

      return { header, rows };
    }

    // ---------- Linear Algebra (small/medium matrices) ----------
    function zeros(r, c) {
      const A = new Array(r);
      for (let i = 0; i < r; i++) {
        A[i] = new Array(c).fill(0);
      }
      return A;
    }

    function copyMat(A) {
      const r = A.length;
      const c = A[0].length;
      const B = zeros(r, c);
      for (let i = 0; i < r; i++) {
        for (let j = 0; j < c; j++) B[i][j] = A[i][j];
      }
      return B;
    }

    function dot(a, b) {
      let s = 0;
      for (let i = 0; i < a.length; i++) s += a[i] * b[i];
      return s;
    }

    function norm2(v) {
      return Math.sqrt(dot(v, v) + EPS);
    }

    function normalize(v) {
      const n = norm2(v);
      for (let i = 0; i < v.length; i++) v[i] /= n;
      return v;
    }

    function matVec(A, v) {
      const r = A.length;
      const out = new Array(r).fill(0);
      for (let i = 0; i < r; i++) {
        const row = A[i];
        let s = 0;
        for (let j = 0; j < v.length; j++) s += row[j] * v[j];
        out[i] = s;
      }
      return out;
    }

    function addShiftedMatVec(A, v, shift) {
      // (A + shift*I) v
      const r = A.length;
      const out = new Array(r).fill(0);
      for (let i = 0; i < r; i++) {
        const row = A[i];
        let s = 0;
        for (let j = 0; j < v.length; j++) s += row[j] * v[j];
        out[i] = s + shift * v[i];
      }
      return out;
    }

    function outer(v) {
      const d = v.length;
      const O = zeros(d, d);
      for (let i = 0; i < d; i++) {
        for (let j = 0; j < d; j++) O[i][j] = v[i] * v[j];
      }
      return O;
    }

    function deflateSym(A, lambda, v) {
      // A <- A - lambda * v v^T
      const d = A.length;
      for (let i = 0; i < d; i++) {
        for (let j = 0; j < d; j++) {
          A[i][j] -= lambda * v[i] * v[j];
        }
      }
    }

    function gershgorinLowerBound(A) {
      // lower bound ~ min_i (a_ii - sum_{j!=i} |a_ij|)
      const d = A.length;
      let lb = Infinity;
      for (let i = 0; i < d; i++) {
        let r = 0;
        for (let j = 0; j < d; j++) {
          if (j !== i) r += Math.abs(A[i][j]);
        }
        lb = Math.min(lb, A[i][i] - r);
      }
      return lb;
    }

    function rayleighQuotient(A, v) {
      const Av = matVec(A, v);
      return dot(v, Av);
    }

    function topEigenSymmetricPower(Ain, k, iters, seed = 12345) {
      // Finds top-k eigenpairs of a symmetric matrix A using:
      // power iteration on shifted matrix (to avoid "largest magnitude negative" dominance),
      // with deflation after each component.
      const A = copyMat(Ain);
      const d = A.length;
      const rng = mulberry32(seed);

      const eigenvalues = [];
      const eigenvectors = [];

      for (let comp = 0; comp < k; comp++) {
        // recompute shift each round for stability
        const lb = gershgorinLowerBound(A);
        const shift = lb < 0 ? (-lb + 1e-6) : 1e-6;

        // random init
        let v = new Array(d);
        for (let i = 0; i < d; i++) v[i] = (rng() * 2 - 1);
        normalize(v);

        // power iterations
        let last = v.slice();
        for (let t = 0; t < iters; t++) {
          const w = addShiftedMatVec(A, v, shift);
          normalize(w);

          // convergence check (cosine similarity)
          const cos = Math.abs(dot(w, v));
          v = w;
          if (t > 20 && cos > 1 - 1e-8) break;
          last = v;
        }

        // compute eigenvalue on ORIGINAL (unshifted) A
        const lambda = rayleighQuotient(A, v);

        eigenvalues.push(lambda);
        eigenvectors.push(v.slice());

        // deflate
        deflateSym(A, lambda, v);
      }

      return { eigenvalues, eigenvectors };
    }

    function covarianceMatrix(X) {
      // X: n x d (assumed mean-centered already)
      const n = X.length;
      const d = X[0].length;
      const C = zeros(d, d);
      const denom = Math.max(1, n - 1);

      for (let i = 0; i < n; i++) {
        const row = X[i];
        for (let a = 0; a < d; a++) {
          const va = row[a];
          for (let b = a; b < d; b++) {
            C[a][b] += va * row[b];
          }
        }
      }
      for (let a = 0; a < d; a++) {
        for (let b = a; b < d; b++) {
          C[a][b] /= denom;
          C[b][a] = C[a][b];
        }
      }
      return C;
    }

    function matSubScaled(A, B, alpha) {
      const d = A.length;
      const M = zeros(d, d);
      for (let i = 0; i < d; i++) {
        for (let j = 0; j < d; j++) M[i][j] = A[i][j] - alpha * B[i][j];
      }
      return M;
    }

    function computeMeanStdMatrix(X) {
      const n = X.length;
      const d = X[0].length;
      const mu = new Array(d).fill(0);
      const sd = new Array(d).fill(0);
      const cnt = new Array(d).fill(0);

      // mean (ignoring NaN)
      for (let i = 0; i < n; i++) {
        const row = X[i];
        for (let j = 0; j < d; j++) {
          const v = row[j];
          if (isFiniteNumber(v)) {
            mu[j] += v;
            cnt[j] += 1;
          }
        }
      }
      for (let j = 0; j < d; j++) mu[j] /= Math.max(1, cnt[j]);

      // std
      for (let i = 0; i < n; i++) {
        const row = X[i];
        for (let j = 0; j < d; j++) {
          const v = row[j];
          if (isFiniteNumber(v)) {
            const dlt = v - mu[j];
            sd[j] += dlt * dlt;
          }
        }
      }
      for (let j = 0; j < d; j++) {
        sd[j] = Math.sqrt(sd[j] / Math.max(1, cnt[j] - 1) + EPS);
        if (!isFiniteNumber(sd[j]) || sd[j] < 1e-9) sd[j] = 1.0;
      }
      return { mu, sd };
    }

    function imputeAndStandardize(X, mu, sd) {
      // returns mean-centered & standardized matrix
      const n = X.length;
      const d = X[0].length;
      const Z = new Array(n);
      for (let i = 0; i < n; i++) {
        const row = X[i];
        const out = new Array(d);
        for (let j = 0; j < d; j++) {
          const v = isFiniteNumber(row[j]) ? row[j] : mu[j]; // impute mean
          out[j] = (v - mu[j]) / sd[j];
        }
        Z[i] = out;
      }
      return Z;
    }

    function projectRows(X, eigenvectors) {
      // X: n x d, eigenvectors: k x d
      const n = X.length;
      const k = eigenvectors.length;
      const scores = new Array(n);
      for (let i = 0; i < n; i++) {
        const row = X[i];
        const s = new Array(k).fill(0);
        for (let c = 0; c < k; c++) {
          s[c] = dot(row, eigenvectors[c]);
        }
        scores[i] = s;
      }
      return scores;
    }

    function reconstructRow(scores, eigenvectors, d) {
      const k = eigenvectors.length;
      const recon = new Array(d).fill(0);
      for (let j = 0; j < d; j++) {
        let s = 0;
        for (let c = 0; c < k; c++) s += scores[c] * eigenvectors[c][j];
        recon[j] = s;
      }
      return recon;
    }

    function topAbsFeatures(vector, featureNames, topN = 10) {
      const idx = vector.map((v, i) => [i, Math.abs(v)]);
      idx.sort((a, b) => b[1] - a[1]);
      return idx.slice(0, topN).map(([i, mag]) => ({
        feature: featureNames[i],
        loading: vector[i],
        absLoading: mag
      }));
    }

    // ---------- Outliers (T² + Q/SPE) ----------
    function computeOutliers(X, eigenvectors, variances, featureNames, topN = 10) {
      const n = X.length;
      const d = X[0].length;
      const k = eigenvectors.length;

      const scores = projectRows(X, eigenvectors);
      const T2 = new Array(n).fill(0);
      const Q = new Array(n).fill(0);

      for (let i = 0; i < n; i++) {
        const s = scores[i];

        let t2 = 0;
        for (let c = 0; c < k; c++) {
          const denom = variances[c] + 1e-9;
          t2 += (s[c] * s[c]) / denom;
        }
        T2[i] = t2;

        const recon = reconstructRow(s, eigenvectors, d);
        let q = 0;
        for (let j = 0; j < d; j++) {
          const r = X[i][j] - recon[j];
          q += r * r;
        }
        Q[i] = q;
      }

      const mT = mean(T2), sT = std(T2);
      const mQ = mean(Q),  sQ = std(Q);

      const combined = [];
      for (let i = 0; i < n; i++) {
        const zt = (T2[i] - mT) / sT;
        const zq = (Q[i] - mQ) / sQ;
        combined.push({ i, T2: T2[i], Q: Q[i], score: zt + zq });
      }
      combined.sort((a, b) => b.score - a.score);

      const outliers = [];
      const limit = Math.min(topN, combined.length);

      for (let t = 0; t < limit; t++) {
        const idx = combined[t].i;
        const s = scores[idx];
        const recon = reconstructRow(s, eigenvectors, d);
        const residualAbs = new Array(d);
        for (let j = 0; j < d; j++) residualAbs[j] = Math.abs(X[idx][j] - recon[j]);

        // top residual contributors
        const pairs = residualAbs.map((v, j) => [j, v]);
        pairs.sort((a, b) => b[1] - a[1]);
        const contrib = pairs.slice(0, 6).map(([j, v]) => ({
          feature: featureNames[j],
          absResidual: v
        }));

        outliers.push({
          rowIndex: idx,
          combinedScore: combined[t].score,
          T2: combined[t].T2,
          Q: combined[t].Q,
          topResidualContributors: contrib
        });
      }

      return outliers;
    }

    // ---------- Plot ----------
    function drawScatter(canvas, target2d, bg2d) {
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const all = [];
      for (const p of target2d) all.push(p);
      for (const p of bg2d) all.push(p);
      if (all.length === 0) return;

      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      for (const [x,y] of all) {
        if (x < minX) minX = x; if (x > maxX) maxX = x;
        if (y < minY) minY = y; if (y > maxY) maxY = y;
      }
      // pad
      const pad = 0.08;
      const dx = (maxX - minX) || 1;
      const dy = (maxY - minY) || 1;
      minX -= dx * pad; maxX += dx * pad;
      minY -= dy * pad; maxY += dy * pad;

      function tx(x) { return (x - minX) / (maxX - minX) * (canvas.width - 40) + 20; }
      function ty(y) { return canvas.height - ((y - minY) / (maxY - minY) * (canvas.height - 40) + 20); }

      // axes
      ctx.globalAlpha = 1;
      ctx.strokeStyle = "#bbb";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(20, 20);
      ctx.lineTo(20, canvas.height - 20);
      ctx.lineTo(canvas.width - 20, canvas.height - 20);
      ctx.stroke();

      // background points
      ctx.fillStyle = "#6c757d";
      ctx.globalAlpha = 0.55;
      for (const [x,y] of bg2d) {
        ctx.beginPath();
        ctx.arc(tx(x), ty(y), 3, 0, Math.PI * 2);
        ctx.fill();
      }

      // target points
      ctx.fillStyle = "#007bff";
      ctx.globalAlpha = 0.75;
      for (const [x,y] of target2d) {
        ctx.beginPath();
        ctx.arc(tx(x), ty(y), 3, 0, Math.PI * 2);
        ctx.fill();
      }

      // legend
      ctx.globalAlpha = 1;
      ctx.fillStyle = "#111";
      ctx.font = "14px system-ui, sans-serif";
      ctx.fillText("Component 1 vs 2", 26, 18);
      ctx.fillStyle = "#007bff"; ctx.fillRect(canvas.width - 160, 18, 12, 12);
      ctx.fillStyle = "#111"; ctx.fillText("Target", canvas.width - 142, 28);
      ctx.fillStyle = "#6c757d"; ctx.fillRect(canvas.width - 90, 18, 12, 12);
      ctx.fillStyle = "#111"; ctx.fillText("Background", canvas.width - 72, 28);
    }

    // ---------- Main cPCA ----------
    function runCPCA(targetCSV, bgCSV, opts) {
      const { delim, hasHeader, k, iters, alphaList, standardizeOnBg } = opts;

      const T = parseCSV(targetCSV, delim, hasHeader);
      if (T.rows.length < 3) throw new Error("Target CSV needs at least 3 data rows.");
      const featureNames = T.header;

      let B = null;
      if (bgCSV.trim().length > 0) {
        B = parseCSV(bgCSV, delim, hasHeader);
        if (B.rows.length < 3) throw new Error("Background CSV needs at least 3 data rows.");
        if (B.header.length !== T.header.length) throw new Error("Target and Background must have same number of columns.");
        // best-effort name match
        for (let i = 0; i < featureNames.length; i++) {
          if (B.header[i] !== featureNames[i]) {
            // allow, but warn in output
            break;
          }
        }
      }

      const XtRaw = T.rows;
      const XbRaw = B ? B.rows : [];

      // standardize
      let mu, sd;
      if (B && standardizeOnBg) {
        ({ mu, sd } = computeMeanStdMatrix(XbRaw));
      } else {
        // pooled stats (target only if no bg)
        const pool = B ? XtRaw.concat(XbRaw) : XtRaw;
        ({ mu, sd } = computeMeanStdMatrix(pool));
      }

      const Xt = imputeAndStandardize(XtRaw, mu, sd);
      const Xb = B ? imputeAndStandardize(XbRaw, mu, sd) : null;

      // covariances
      const Ct = covarianceMatrix(Xt);
      const Cb = Xb ? covarianceMatrix(Xb) : null;

      // choose alpha + components
      let best = null;

      if (!Cb) {
        // PCA fallback (alpha = 0)
        const eig = topEigenSymmetricPower(Ct, k, iters, 1337);
        best = {
          alpha: 0,
          eigenvalues: eig.eigenvalues,
          eigenvectors: eig.eigenvectors,
          score: eig.eigenvalues.reduce((s, v) => s + Math.max(0, v), 0)
        };
      } else {
        for (const alpha of alphaList) {
          const M = matSubScaled(Ct, Cb, alpha);
          const eig = topEigenSymmetricPower(M, k, iters, 1337);
          const score = eig.eigenvalues.reduce((s, v) => s + Math.max(0, v), 0);
          if (!best || score > best.score) {
            best = {
              alpha,
              eigenvalues: eig.eigenvalues,
              eigenvectors: eig.eigenvectors,
              score
            };
          }
        }
      }

      // compute variances along components in Target and Background
      const varT = best.eigenvectors.map(v => rayleighQuotient(Ct, v));
      const varB = Cb ? best.eigenvectors.map(v => rayleighQuotient(Cb, v)) : null;

      // feature loadings per component
      const topFeatures = best.eigenvectors.map((v, idx) => ({
        component: idx + 1,
        top: topAbsFeatures(v, featureNames, 12)
      }));

      // 2D projection for plot
      const v1 = best.eigenvectors[0] || null;
      const v2 = best.eigenvectors[1] || null;
      const tgt2d = [];
      const bg2d = [];
      if (v1 && v2) {
        for (let i = 0; i < Xt.length; i++) tgt2d.push([dot(Xt[i], v1), dot(Xt[i], v2)]);
        if (Xb) for (let i = 0; i < Xb.length; i++) bg2d.push([dot(Xb[i], v1), dot(Xb[i], v2)]);
      }

      // outliers (target)
      const outliers = computeOutliers(Xt, best.eigenvectors, varT, featureNames, 10);

      return {
        meta: {
          algorithm: Cb ? "Contrastive PCA (cPCA)" : "PCA (no background provided)",
          nTarget: Xt.length,
          nBackground: Xb ? Xb.length : 0,
          dFeatures: featureNames.length,
          chosenAlpha: best.alpha,
          salientScore: best.score,
          iterations: iters,
          k
        },
        eigen: {
          eigenvalues_M: best.eigenvalues, // eigenvalues of (Ct - alpha Cb)
          varTarget: varT,
          varBackground: varB
        },
        topFeatures,
        outliers,
        projections2D: { target: tgt2d, background: bg2d }
      };
    }

    // ---------- UI Rendering ----------
    function escapeHtml(s) {
      return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;");
    }

    function renderResults(res) {
      const div = document.getElementById("results");
      const m = res.meta;

      let html = "";
      html += `<div class="small"><b>${escapeHtml(m.algorithm)}</b></div>`;
      html += `<div class="small">Target rows: <b>${m.nTarget}</b> • Background rows: <b>${m.nBackground}</b> • Features: <b>${m.dFeatures}</b></div>`;
      html += `<div class="small">Chosen alpha: <b>${m.chosenAlpha}</b> • Salient score: <b>${m.salientScore.toFixed(4)}</b> • Components k: <b>${m.k}</b></div>`;

      html += `<h4 style="margin:12px 0 6px;">Component summary</h4>`;
      html += `<table><thead><tr>
        <th>Component</th>
        <th>Eigenvalue of (Ct - αCb)</th>
        <th>Target variance (vᵀCt v)</th>
        <th>Background variance (vᵀCb v)</th>
      </tr></thead><tbody>`;

      for (let i = 0; i < m.k; i++) {
        const ev = res.eigen.eigenvalues_M[i] ?? 0;
        const vt = res.eigen.varTarget[i] ?? 0;
        const vb = res.eigen.varBackground ? (res.eigen.varBackground[i] ?? 0) : 0;
        html += `<tr>
          <td>${i+1}</td>
          <td>${ev.toFixed(6)}</td>
          <td>${vt.toFixed(6)}</td>
          <td>${(m.nBackground ? vb.toFixed(6) : "—")}</td>
        </tr>`;
      }
      html += `</tbody></table>`;

      html += `<h4 style="margin:12px 0 6px;">Top features driving each component (by |loading|)</h4>`;
      for (const comp of res.topFeatures) {
        html += `<div style="margin:8px 0;"><b>Component ${comp.component}</b></div>`;
        html += `<table><thead><tr><th>Feature</th><th>Loading</th><th>|Loading|</th></tr></thead><tbody>`;
        for (const t of comp.top) {
          html += `<tr>
            <td>${escapeHtml(t.feature)}</td>
            <td>${t.loading.toFixed(6)}</td>
            <td>${t.absLoading.toFixed(6)}</td>
          </tr>`;
        }
        html += `</tbody></table>`;
      }

      html += `<h4 style="margin:12px 0 6px;">Target outliers (high T² + high Q/SPE)</h4>`;
      html += `<table><thead><tr>
        <th>Row</th><th>Combined score</th><th>T²</th><th>Q/SPE</th><th>Top residual contributors</th>
      </tr></thead><tbody>`;
      for (const o of res.outliers) {
        const contrib = o.topResidualContributors
          .map(c => `${escapeHtml(c.feature)} (${c.absResidual.toFixed(4)})`)
          .join("<br/>");
        html += `<tr>
          <td>${o.rowIndex}</td>
          <td>${o.combinedScore.toFixed(3)}</td>
          <td>${o.T2.toFixed(4)}</td>
          <td>${o.Q.toFixed(4)}</td>
          <td>${contrib}</td>
        </tr>`;
      }
      html += `</tbody></table>`;

      div.innerHTML = html;
    }

    // ---------- Buttons ----------
    let lastResults = null;

    document.getElementById("runBtn").addEventListener("click", () => {
      try {
        const targetCSV = document.getElementById("csvTarget").value;
        const bgCSV = document.getElementById("csvBg").value;
        const delim = document.getElementById("delim").value || ",";
        const hasHeader = document.getElementById("hasHeader").checked;
        const k = clamp(parseInt(document.getElementById("k").value, 10) || 3, 1, 20);
        const iters = clamp(parseInt(document.getElementById("iters").value, 10) || 250, 30, 3000);
        const standardizeOnBg = document.getElementById("standardizeOnBg").checked;

        const alphaList = (document.getElementById("alphas").value || "0,1,2,5")
          .split(",")
          .map(s => Number(s.trim()))
          .filter(x => Number.isFinite(x) && x >= 0)
          .slice(0, 40);

        if (alphaList.length === 0) throw new Error("Alpha candidates list is empty/invalid.");

        const res = runCPCA(targetCSV, bgCSV, { delim, hasHeader, k, iters, alphaList, standardizeOnBg });
        lastResults = res;

        renderResults(res);

        const canvas = document.getElementById("plot");
        drawScatter(canvas, res.projections2D.target, res.projections2D.background);

        document.getElementById("downloadBtn").disabled = false;
      } catch (e) {
        lastResults = null;
        document.getElementById("downloadBtn").disabled = true;
        document.getElementById("results").innerHTML =
          `<pre>${escapeHtml(String(e && e.message ? e.message : e))}</pre>`;
      }
    });

    document.getElementById("demoBtn").addEventListener("click", () => {
      // Tiny synthetic demo: Target has a signal in features 1 & 3; Background mostly noise
      const header = ["feat1","feat2","feat3","feat4","feat5"].join(",");
      const rng = mulberry32(42);

      function rowTarget() {
        // enriched structure: feat1 and feat3 correlated + bigger variance
        const z = (rng()*2-1);
        const f1 = 2.2*z + 0.3*(rng()*2-1);
        const f3 = 1.8*z + 0.3*(rng()*2-1);
        return [f1, 0.5*(rng()*2-1), f3, 0.6*(rng()*2-1), 0.6*(rng()*2-1)];
      }
      function rowBg() {
        // mostly noise
        return [0.7*(rng()*2-1), 0.7*(rng()*2-1), 0.7*(rng()*2-1), 0.7*(rng()*2-1), 0.7*(rng()*2-1)];
      }

      let t = header + "\n";
      let b = header + "\n";
      for (let i = 0; i < 120; i++) t += rowTarget().map(v => v.toFixed(5)).join(",") + "\n";
      for (let i = 0; i < 120; i++) b += rowBg().map(v => v.toFixed(5)).join(",") + "\n";

      document.getElementById("csvTarget").value = t;
      document.getElementById("csvBg").value = b;
    });

    document.getElementById("downloadBtn").addEventListener("click", () => {
      if (!lastResults) return;
      const blob = new Blob([JSON.stringify(lastResults, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "results.json";
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    });
  </script>
</body>
</html>
